#include "FeatUnit.h"
  
// нечетная подгонка
void OddFeat(TSignal & inY, TSignal &outY)
{
    int size=inY.size();
    outY.resize(size/2); // Размер уменьшится вдвое.
/*
    Нечетное усреднение
    имеем
    f(-x)=-f(x)
    Тогда среднее есть сумма двух одинаковых значений поделенная пополам.
    В итоге получаем:

    (f(-x)+(-f(x)))/2.0
    Т.е.
    (f(-x)-f(x))/2.0

    Но возникает вопрос со знаком.
    По идее сигнал сюда приходит комбинированный, а значит
    нулевой элемент соответствует индукции -2 Тл.
    Получается нам надо взять знак этого элемента и изменить на противоположный -
    это и будет тот знак, который нам так нужен.

    Если пытаться использовать элементы из середины - велика вероятность ошибки,
    т.к. из-за неоднородностей образца для нулевого магнитного поля идеально
    нулевых значений напряжения Холла получить не удаётся.
    Оно будет близким к нулю, при этом справа или слева - предсказать не получится.
    
    С магнитным полем это действует достаточно хорошо, но вот если речь идет
    о сигнале - возникают некоторые проблемы.
    Поэтому лучше брать знак той точки, которую усредняем. Выглядит логично.


    И вот я нашел ещё один косят - а что если функция не меняет знака?
    На всей протяженности знак одинаковый и тут понеслась....

    Так, мы симметричны относительно точки B=0 и некоторого значения сигнала,
    которое соответствует полю равному 0.
    Вопрос - как нам узнать это значение?
    В общем случае один из краев или центр входного сигнала должен быть
    близким к нулю, но он может быть близким к нему, но так его и не пересечь.

    */
    for(int i=0;i<size/2;i++)
        {

        if( sign(inY[0]*sign(inY.back()))<0) // тогда если по краям знаки разные
            outY[i]=-sign(inY[i])*fabs((inY[i]-inY[size-1-i]))/2.0;
        else
            outY[i]=sign(inY[i])*fabs((inY[i]-inY[size-1-i]))/2.0;

            //outY[i]=sign(inY[size-1-i])*fabs((inY[i]-inY[size-1-i]))/2.0;
            //outY[i]=-sign(inY[i])*fabs((inY[i]-inY[size-1-i]))/2.0;
            //outY[size-1-i]=-inY[i];
        }
        // Поскольку начинали с дальнего края - реверсим вектор.
    std::reverse(outY.begin(),outY.end());
}

// четная подгонка
void EvenFeat(TSignal & inY, TSignal &outY)
{
    int size=inY.size();
    outY.resize(size/2); // Размер уменьшится вдвое.
/*
    Так, теперь выясняется что и тут не всё так просто.
    Есть у нас четная симметрия.
    Относительно оси Y
    Сие означает, что для противоположных значений индукции магнитного поля значения данной функции равны
    f(-B)=f(B)
    Для обычных входных данных нет никаких проблем и эта простая формула работает.
    Но для фильтрованных сигналов, с увеличением длины фильтра возрастает погрешность - мы усредняем не те точки.
    Нужно усреднять относительно точки В=0
    Т.е. надо:
    1. найти точку В=0
    2. получить её индекс
    3. усреднить относительно её те точки что получится
    4. недостающие (для высоких значений магнитных полей, при длинном фильтре они экстраполируются) взять из исходного сигнала, без усреднения
    P.S. Не уверен насчет поведения недостающих точек, но попробовать стоит.
    5. Да, дозапись неусредненных - плохая идея, что будем делать?

    */

    // С точкой B=0 всё более-менее просто - 
    // Найдем минимум нашего сигнала, он и будет центральной точкой
    MyDataType min=0;
    for (int i = 1; i < size; ++i)
    {
        if (inY[min]>inY[i])
        {
            min=i;
        }
    }
    //ShowMessage(FloatToStr(inY[min])+" "+IntToStr((int)min));
        
    for(int i=0;i<size/2;i++)
    {
        
        
        if (min+i<size && min-i>=0)
        {
            outY[i]=(inY[min-i]+inY[min+i])/2.0;
        }
        else
        {                
            if (min-i<0 && min+i<size)
            {
                outY[i]=inY[min+i];
            }
            else
            {
                if (min-i>=0)
                {
                    outY[i]=inY[min-i];
                }                   
            }
        }
        //outY[i]=(inY[i]+inY[size-1-i])/2.0;
        //tempY[size-1-i]=tempY[i];

    }
}

  /*

// Код дальше насколько я понимаю не используется больше.
void FeatCurve(TLineSeries* a, long index, FeatType featType)
{
    int size=a->XValues->Count();
    if(size==0)
    {
        ShowMessage("Получен пустой массив данных!!!");
        return;
    }
    TChartValueList * b,*c;

    // параметры массив и переменная относительно которой функция нечетна
    // 0 для х, 1 для y

    if(!index)
    {
        c=a->YValues;
        b=a->XValues;
    }
    else
    {
        b=a->YValues;
        c=a->XValues;
    }
    for(int i=0;i<size/2;i++)
    {
        b->Value[i]=(b->Value[i]-b->Value[size-1-i])/2.0;
        b->Value[size-1-i]=-b->Value[i];
        switch(featType)
        {
        case ODD_FEAT: // нечетная подгонка
            c->Value[i]=(c->Value[i]-c->Value[size-1-i])/2.0;
            c->Value[size-1-i]=-c->Value[i];
            break;
        case EVEN_FEAT: // четная подгонка
            c->Value[i]=(c->Value[i]+c->Value[size-1-i])/2.0;
            c->Value[size-1-i]=c->Value[i];
            break;
        }

    }
}
     */
//---------------------------------------------------------------------------
// нечетная подгонка
// параметры массив и переменная относительно которой функция нечетна
// 0 для х, 1 для y
void  OddFeat(TLineSeries* a, long index)
{
    FeatCurve(a,index,ODD_FEAT);
}
//-----------------------------------------------------------------------------
//четная подгонка
// параметры массив и переменная относительно которой функция нечетна
// 0 для х, 1 для y
void  EvenFeat(TLineSeries* a, long index)
{
    FeatCurve(a,index,EVEN_FEAT);
}
//-----------------------------------------------------------------------------
//----------Подгонка Фотопроводимости в геометрии Фойгта-----------------------
void  FoygtFeat(TLineSeries* a,TLineSeries* b, long index)
{
    int size=a->XValues->Count();
    if(size==0 || b->XValues->Count()==0)
    {
        ShowMessage("Получен пустой массив данных!!!");
        return;
    }

    for(int i=0;i<size;i++)
    {
        a->XValues->Value[i]=(a->XValues->Value[i]-b->XValues->Value[size-1-i])/2;
        a->YValues->Value[i]=(a->YValues->Value[i]-b->YValues->Value[size-1-i])/2;
    }
}
//-----------------------------------------------------------------------------
// усреднение двух кривых
// индекс - зарезервирован, пока не используется
// функция сохраняет результат в ПЕРВЫЙ передаваемый массив!
void  MidCurve(TLineSeries* a, TLineSeries* b, long index)
{

    int size=a->XValues->Count();

    if(size==0 || b->XValues->Count()==0)
    {
        ShowMessage("Получен пустой массив данных!!!");
        return;
    }
    if(a->XValues->Count()!=b->XValues->Count())
    {
        ShowMessage("Разное количество точек на графиках!!!");
        return;
    }

    for(int i=0;i<size;i++)
    {
    a->XValues->Value[i]=(a->XValues->Value[i]+b->XValues->Value[i])/2;
    a->YValues->Value[i]=(a->YValues->Value[i]-b->YValues->Value[i])/2;
    }
}